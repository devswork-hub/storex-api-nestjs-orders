`Decis√£o`: Usar Scope.REQUEST diretamente no decorator @Injectable() ao inv√©s de definir o escopo no array de providers.

`Contexto`: Projeto NestJS com necessidade de inje√ß√£o de depend√™ncias com escopo por requisi√ß√£o.

## üéØ Problema

Alguns servi√ßos precisam ser instanciados a cada requisi√ß√£o, como o UnitOfWork, que depende do contexto de transa√ß√£o ou usu√°rio. Para isso, o NestJS oferece o escopo Scope.REQUEST.

H√° duas formas de declarar um escopo no NestJS:

1. Via decorator no pr√≥prio servi√ßo:

```ts
@Injectable({ scope: Scope.REQUEST })
export class UnitOfWork { ... }
```

2. Via array de providers no m√≥dulo:

```ts
providers: [
  {
    provide: UnitOfWork,
    useClass: UnitOfWork,
    scope: Scope.REQUEST,
  },
];
```

# ‚úÖ Decis√£o

Optei por declarar o escopo diretamente no decorator @Injectable, da seguinte forma:

```ts
@Injectable({ scope: Scope.REQUEST })
export class UnitOfWork { ... }
```

## üìå Justificativas

- üîç Clareza na defini√ß√£o: A anota√ß√£o no pr√≥prio arquivo da classe facilita para outros desenvolvedores entenderem rapidamente que o servi√ßo √© request-scoped, sem precisar ca√ßar no array de providers.
- üìÅ Coes√£o por responsabilidade: A classe UnitOfWork sabe de sua natureza request-scoped, ent√£o faz sentido declarar isso nela mesma, tornando-a autossuficiente.
- ‚ö†Ô∏è Menor risco de erro: Definir no provider exige lembrar de configurar escopo manualmente toda vez que usar a classe. Com o decorator, o comportamento √© garantido em qualquer lugar do projeto onde ela for usada.
- üìö Recomenda√ß√£o da documenta√ß√£o do NestJS: A pr√≥pria documenta√ß√£o oficial usa o padr√£o com @Injectable({ scope: ... }).

# üîÑ Implica√ß√µes

- Servi√ßos request-scoped s√≥ podem ser injetados em escopos iguais ou maiores (por exemplo: outros servi√ßos request ou transient).
- Ao injetar um request-scoped em um handler singleton, deve-se usar ModuleRef.resolve() para evitar erros de escopo.
- Isso impacta o uso com CQRS, onde muitos CommandHandlers s√£o singleton por padr√£o.

# Exemplo com ModuleRef

```ts
@Injectable()
export class MyHandler implements ICommandHandler {
  constructor(private readonly moduleRef: ModuleRef) {}

  async execute(command: MyCommand): Promise<void> {
    const uow = await this.moduleRef.resolve(UnitOfWork, { strict: false });
    await uow.commit();
  }
}
```
